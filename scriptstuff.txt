
# What is BetterEditor?

### Demos for Editor Development
- Shows how to create a feature complete, fully customized Editor for a component.
- Responds to changes across complicated Undo/Redo/Revert/Reset operations.

### SerializedTrackers
- Provides full information of exactly which properties have been updated and how.
- Trackers completely replace SerializedProperties.
- Adapts easily to changes in source component data-structure.
- Trackers can be gathered via reflection, improving adaptability.

### The BetterEditor Object
- A complete framework for an Editor, calls methods at the correct times.
- Provides a more reliable and adaptable ".targets" list.
- Triggers a full refresh when the UnityEditor is hot-reloaded from script changes.
- Informs whether updates are made from GUI, or undo/redo operations.
- Additional options for Logging / Triggering full refreshes.

### Quality of Life Extensions for SerializedProperty
- Number and Boolean methods.
- Safer Clamps/Min/Max via Enforce methods.
- Automatic GUIContent generation (including [Tooltip] grabber).
- ... and More.

### BetterGUI
- Provides missing "Serialized" GUI elements.
- Provides a RowBuilder framework to compact multiple properties to a single row.
- ... and More.

### BetterUndo
- Provides all of Unity's Undo methods with a `#if UNITY_EDITOR` preprocessor check.
- BetterUndo.DestroyImmediate will safely call the runtime version of Object.DestroyImmediate instead.

### BetterBookmark
- A tagged "ScriptableObject" which can be located along with its folder path.
- Useful for locating and loading assets (for editor use) without the use of /resource/ folders.
- Useful for publishing addons like this one, and used to power the demos.

	  
-- Intro --   
	  
This is an introduction to developing with Unity's Editor and Editor Gooey classes, which allows one to build tools and fully customized, powerful inspectors, for use within the Unity Editor. Everything shown in the video is available in the distribution demo scene provided with the BetterEditor library, which was designed to ease some of the headaches we'll surely encounter.

-- What are we making -- 

Throughout the video, we'll be developing a fully-customized Inspector, known as an Editor, for a demo component. The demo component creates and distributes objects in a radius, when triggered from the Editor. The editor behaves exactly as you would expect; Differences between multiple objects (or variations from a prefab definition) are clearly marked. This editor utilizes a reusable custom row which holds both a boolean and color, and that row can be copied and pasted in full. But most importantly, the editor in this demo is able to detect changes to individidual properties across all possible operations, of which there are five (and probably more)
      1. Basic Gooey interaction
	  2. Copy+Paste
	  3. Revert
	  4. Reset
	  5. and Undo+Redo
When changes to "important" properties occur from any of these operations, the editor shows that the distribution is out of date and that it needs to be reapplied. On top of all of this, Undos and Redos are handled correctly. 


That may sound like a lot, but we'll be working up to that goal in stages and covering all of the fundamentals along the way. To this effect, the components in the Demo scene include a drop-down to swap between six stages of complexity. The first stage is as simple as an Editor can get and doesn't contain much functionality, while the 6th stage has all of the functionality. The respective CS files can be opened as well, and they contain enough comments to replace this entire video.

-- BetterEditor's role --

In the later stages, this demo makes heavy use of the Better Editor library. SerializedProperties are replaced with BetterEditor's Trackers, to track updates to individual properties and provide flexibility. We'll use many of BetterEditor's Serialized extension methods to make working with Properties easier. We'll use BetterEditor's Gooey methods and Row-Builder to create a custom row. In the final step, the BetterEditor object is employed, which acts a framework for an Editor and provides some nifty features.   


-- The Component -- 

To begin, let's quickly look at our component or Monobehaviour. Through some internal magic, this component is reused as the target for all 6 Editors in the demo. This component defines a few "preview" properties, which control a gizmo visualizing the radius. There are also properties which modify the distribution, such as the seed, a list of objects to distribute, and a color override. 


The two color properties are of the same type, "???", which is a class that simply contains a boolean and a color.

-- Stage 1: Basic Custom Editor --

This is a barebones Editor class, which overrides how the component is drawn within the Inspector. The class inherits from Unity's :Editor class. The "Can-Edit-Multiple-Objects" tag allows for multi-select, and the "CustomEditor" tag specifies the target Component class. 

In this stage, the Gooey is drawn using Editor's "Draw-Default-Inspector" method, which produces the default look for our component's serialized fields. This is called from the OnInspectorGooey method, which is triggered whenever the inspector panel is redrawn or interacted with. In order to detect changes to data, Unity's BeginChangeCheck() and EndChangeCheck() are used. However these methods fail to catch changes caused by Undo, Revert, or other complicated operations. Furthermore, we've only stored the "Has-Modifications" variable locally, and this boolean is obliterated when changing selection. 


-- Serialized Object Primer --

Before moving on past step 1, we'll need to understand Serialized Objects. Serialized objects are collections of properties across multiple Unity Objects, and when working with the Unity Editor class, a serializedObject property is provided which represents all selected target components. Any property from our component class can be retrieved as a SerializedProperty, which represents the property's value across ALL selected objects. This means that by grabbing the 
"enablePreview" property from the provided serializedObject, we are given a Boolean SerializedProperty with access to a .boolValue . This basic getter/setter allows us to work with the Boolean property across all of our selected objects, but it isn't the full picture. In addition to providing the basic value, another property "hasMultipleDifferentValues" is also provided, which is true when there is any mismatched data across our objects. These serialized properties are used to power the majority of Unity's UI, and when hasMultipleDifferentValues is true, a slash in the input field denotes the inconsistency. 

More powerful editors will make heavy use of SerializedProperty, and as we get into more complicated examples, we'll find ourselves creating a SerializedProperty for every single field which we wish to render in the Editor. 


-- Stage 2: Iterating Properties ---

In stage 2 we replace Unity's "Draw-Default-Inspector" with a loop that iterates over each SerializedProperty available, which is what "draw-default-inspector" was doing internally. Before iterating these properties, we first assign some properties  such as "enablePreviewProp". This property is a SerializedProperty gathered from the given serializedObject, using SerializedObject.FindProperty(). It's a great practice to use C#'s nameof() where possible when gathering SerializedProperties, to help prevent Editor bugs when a property is refactored to a different name later on. Within the loop body, we can perform additional checks, such as hiding or disabling individual properties based on anything we'd like. In this case, we hide the "m_script" property, which is the Unity default property in each component which points to the script asset. We use Unity's Gooey.enabled flag to disable the "previewColor" property when "enablePreview" is false across the entire selection, making use of BetterEditor's AnyTrue() method applied to the Serialized Property we gathered before. To actually draw the control, we use Unity's `EditorGooeyLayout.PropertyField` method, which draws a full row given any type of serializedProperty automagically. 

In this stage, we use serializedObject.hasModifiedProperty in order to set the hasModifications flag. This property is intended to denote when changes to the serializedObject have been made, but it still fails to catch the same changes from complicated operations. 


-- Stage 3: Fully customized Editor --

In stage 3, things get a lot more verbose, as we start by collecting every one of the component's property's as a SerializedProperty. In this stage, we use BetterEditor's FindPropertyChecked extension, which throws a clear error if the property isn't found. These properties are used in OnInspectorGooey(), where a fully customized UI is composed, making use of all of Unity's PropertyField method and customization options. In this demo, we manually add additional category labels, apply custom indentation, build a custom foldout, and add a bunch of logic to disable properties in certain conditions. BetterEditor's "Enforce" extension methods are used on numerical SerializedProperties to provide soft range-clamping, after drawing the UI. 

-- S3: Tracking changes to SerializedProperties --

In stage 3, we also start properly tracking changes to serializedProperties. In order to do this without BetterEditor's help, we need to create two variables for each SerializedProperty which will be used to track the property's previous values. Of these two properties, the second is always a Boolean which is used to track the previous value of "hasMultipleDifferentValues". This is because "hasMultipleDifferentValues" can change without the primary value changing, but this is still a valid change in data which should be tracked. These tracking properties are assigned within the "RefreshTracking" method, based on the current values from each SerializedProperty. Additionally, we track changes to the objectPrefabs List using a different methodology. RefreshTracking() is called when the object is enabled, and will not be called again for the time-being. 

Instead, CheckForUpdates() is called from OnInspectorGooey often, after all of our UI is drawn and logic applied. This method checks every SerializedProperty against the tracker variables in order to detect changes in various categories, which in this case are "Preview", "Distribution", and "Objects". By using this setup, we've solved a number of problems. Most importantly: this setup is able to track changes from all sources including Undo, Redo, Revert, Reset, and Paste. And because we have full control, we can now ignore changes to preview properties, as these don't require any changes and aren't considered modifications to core data.

We're also handling the hasModifications property correctly now by saving it to the component itself and accessing it like any other SerializedProperty. In this setup the modification flag will persist, even if we switch our selection and return to the component later.


-- Stage 4: Using Better Editor for easier Tracking --

BetterEditor's primary purpose is to assist in tracking changes like we did in the last step, without the need to create 3 variables for each target property. In order to do this, SerializedProperty is completely replaced with  BetterEditor's Tracker, which will provide a reference to a SerializedProperty once setup. Trackers are given their property name immediately when initialized. An "allTrackers" TrackerGroup is defined to hold a reference to every single Tracker which we're working with. In OnEnable() it is easily populated via reflection to ease future refactors. Additional lists are setup to separate between "Preview" properties and "Important" properties, and any supporting SerializedProperties are still gathered like normal. The RefreshTracking() method is improved by using Tracker's Track Method. Some of our properties are gathered directly from the serializedObject, and some of them are relative, such as the "use" and "color" properties gathered from the two classes. 

With this setup in place, we can easily check for changes using the WasUpdated() methods in OnInspectorGooey(). These methods provide an option for Logging verbosity, allowing you to confirm that the system is catching all of the updates you intended.

In addition to cutting our code footprint in half with BetterEditor, we've also made some other significant improvements. Each Tracker is completely type agnostic and is able to track updates without knowing about the type of SerializedProperty it's being provided, reducing headaches and improving refactorability. 


-- Stage 5: Separating out Mini-Editors --

In the previous 4 examples, we've needed to duplicate code and properties for the two color objects, each containing a "use" and a "color" property. In this stage, we begin by creating a class which is dedicated to drawing this SpheresDemo_ColorData class while providing all of the same update tracking functionality from the previous example. The class extends from ITrack interface to allow it to be gathered via reflection or used in a similar fashion to any other BetterEditor Tracker. A TrackerGroup is defined to represent all Trackers within our Color class, and it's given an expected class to gather from, unlike our previous group. Trackers are setup for our two properties, similar to before. A constructor provides an opportunity to override the default GooeyContent, which represents the label and tooltip for this specific Color object. The group must also be initialized with a relative property name, such that Track()
will cause the properties to be gathered from the correct ColorData class. Finally, our new class has a custom Draw method, which uses BetterEditor's CustomRow methods to draw a very unique row with multiple properties, which can be copied and pasted as a group like any other class or struct. 

The class we've just created is then reused twice alongside other Trackers, with the names of the two different properties which they are meant to target provided. The second one is given a custom GooeyContent. These are gathered into a TrackerGroup using the same PopulateWithReflection as before. Finally, all tracking can occur directly through the group.Track() method.

The second half of the demo splits out another class meant to draw and track changes to our Component, similarly to how we setup a class for our ColorData class. This is an overcomplicated example and doesn't provide a ton of value here. How but this sort of architecture or philosophy could prove useful. The idea is that layers of Trackers, or ITrack powered classes, can be stacked and substituted cleanly. 


-- Stage 6: --





What is BetterEditor?

- Demos for Editor Development

- BetterEditor Trackers: Track updates to Serialized Properties

- QOL Extensions for SerializedProperties

- BetterEditor Object: Framework for Editor with extra features

- BetterGUI: GUI extensions and missing serialized UI elements

- BetterUndo: flexible undo available at runtime

- BetterBookmark: non-resource access to directories for editor









